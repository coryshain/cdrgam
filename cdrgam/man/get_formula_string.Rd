% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model.R
\name{get_formula_string}
\alias{get_formula_string}
\title{Compute a standard CDR-GAM formula string}
\usage{
get_formula_string(
  irfs = NULL,
  k = 5,
  k_t = 10,
  bs = "cr",
  bs_t = "cr",
  use_intercept = TRUE,
  use_rate = TRUE,
  ran_gf = NULL,
  others = NULL,
  t_delta_col = "t_delta",
  mask_col = "mask"
)
}
\arguments{
\item{irfs}{A character vector of predictor names, or a list of character
vectors of predictor names, or a list of lists of character vectors of
predictor names. If a list, each element of the list--i.e., each
(possibly singleton) set of predictors--defines a separate smooth
that will be added to the model. If a list of lists, each element must
be a pair (list of length 2) in which the first subelement (named
"inputs") is a character vector of predictors to include in the
inputs to the IRF, and the second subelement (named "impulses") is
a character vector of impulses to convolve using the IRF.
A smooth involving multiple predictors will represent an IRF of the
interaction of all predictors in the set. For example, \code{c('a', 'b')} will
create independent IRFs for \code{a} and \code{b}, whereas
\code{list('a', 'b', c('a', 'b'))} will additionally create an IRF of the
interaction of \code{a} and \code{b}.}

\item{k}{A numeric or list of numerics, the degree of the IRF splines for
each predictor. If a single numeric, the same value is used for all
predictors.}

\item{k_t}{A numeric or list of numerics, the degree of the IRF splines for
the time delta variable of each IRF. If a single numeric, the same value
is used for all predictors.}

\item{bs}{A character or list of characters, the basis function for the
IRF splines for each predictor. If a single character, the same value is
used for all IRFs. See \code{?mgcv::smooth.terms} for details. If NULL,
the IRF will be constrained to be linear in the predictor.}

\item{bs_t}{A character or list of characters, the basis function for the
IRF splines for the time delta variable of each IRF. If a single character,
the same value is used for all IRFs. See \code{?mgcv::smooth.terms} for details.}

\item{use_intercept}{A logical, whether to include an intercept term}

\item{use_rate}{A logical, whether to a rate (deconvolutional
intercept) term}

\item{ran_gf}{A string containing the name of a random grouping factor. If
provided, the formula will interact all terms with the random grouping factor.
If NULL, the string will represent fixed effects terms.}

\item{others}{A character vector of additional \code{mgcv} GAM terms to include
in the model without convolving them. All predictors in these terms must
be found in the response data (\code{Y}), since only the response is guaranteed
to be conformable without convolution. To distinguish these terms (encoded
as vectors) from potentially identically-named convolved predictors (encoded
as matrices), the column must be suffixed with '_Y' in the term. Thus, to
add a term that fits a non-convolutional smooth to a predictor called \code{time},
the term should use \code{time_Y}, e.g.:
\code{te(time_Y, k=10, bs='cr')}}

\item{t_delta_col}{A string specifying the name of the column
containing the difference in time between impulses and response.}

\item{mask_col}{A string specifying the name of the column
containing the mask over valid timepoints.}
}
\value{
A string representing the RHS of the model formula
}
\description{
Compute a string representation of the right-hand side (RHS) of a standard
CDR-GAM formula from a set of preditors (or predictor sets in the case of
interactions) and optional parameters.
}
\details{
Model formulas can of course be hand written, so this is simply a
convenience function for typical cases, which guarantees that the
resulting model is a valid CDR-GAM. However, since the function returns
a string, the output can be edited as needed by the modeler in special
cases. The function returns either a set of fixed effects terms or a set
of random effects terms (if \code{ran_gf} is provided). Thus, to construct
mixed models, simply call this function multiple times, once for the
fixed effects specification and once for each random effects specification,
and concatenate the results with a \code{+} separator.

This leverages the \code{linear.functional.terms} feature of \code{mgcv}, which
\emph{sums} the results of applying the same smooth to multiple values of a
predictor for a given datapoint, weighting the elements in the
summation by the value of the variable supplied to the \code{by} term of the
smooth. When such a smooth is parameterized by the time offset \emph{t_delta}
and \code{by} is the impulse (predictor), a \code{linear.functional.term} becomes
a discrete convolution over time, where the smooth represents the
impulse response. If the smooth is also parameterized by the impulse
itself, then the IRF can be non-linear in the impulse.

For example, the following \code{mgcv} term defines an IRF that is linear
in predictor \code{a}, assuming that \code{t_delta} and \code{a} are both supplied
as matrices as required by \code{linear.functional.terms} (see
\code{get_cdr_data()} for details):
\code{te(t_delta, k=10, bs='cr', by=a)}
By contrast, the following defines an IRF that is nonlinear in \code{a}
(because \code{a} also parameterizes the smooth itself):
\code{te(t_delta, a, k=c(10, 5), bs=c('cr', 'cr'), by=a)}
}
